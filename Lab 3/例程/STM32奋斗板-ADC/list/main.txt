; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I\\Mac\Home\Desktop\嵌入式系统\实验\实验3\例程\STM32奋斗板-ADC\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\main.crf user\main.c]
                          THUMB

                          AREA ||i.ADC_Configuration||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;76     ****************************************************************************/ 
;;;77     void ADC_Configuration(void)
000000  b570              PUSH     {r4-r6,lr}
;;;78     {
000002  b092              SUB      sp,sp,#0x48
;;;79     	ADC_InitTypeDef ADC_InitStructure;
;;;80     	GPIO_InitTypeDef GPIO_InitStructure;
;;;81     	DMA_InitTypeDef DMA_InitStructure;
;;;82     
;;;83         //设置AD模拟输入端口为PC1   
;;;84       	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000004  2002              MOVS     r0,#2
000006  f8ad0040          STRH     r0,[sp,#0x40]
;;;85       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;//模拟输入
00000a  2400              MOVS     r4,#0
00000c  f88d4043          STRB     r4,[sp,#0x43]
;;;86       	GPIO_Init(GPIOC, &GPIO_InitStructure);
000010  a910              ADD      r1,sp,#0x40
000012  4831              LDR      r0,|L1.216|
000014  f7fffffe          BL       GPIO_Init
;;;87     	 /* Enable DMA clock */
;;;88         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;89        /* Enable ADC1 and GPIOC clock */
;;;90         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
000020  2101              MOVS     r1,#1
000022  0248              LSLS     r0,r1,#9
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;91     
;;;92     	//使能DMA
;;;93     	DMA_DeInit(DMA1_Channel1);
000028  4e2c              LDR      r6,|L1.220|
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       DMA_DeInit
;;;94     	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;			 //DMA通道1的地址 
000030  482b              LDR      r0,|L1.224|
;;;95     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue; //DMA传送地址
000032  9000              STR      r0,[sp,#0]
000034  482b              LDR      r0,|L1.228|
;;;96     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;					     //传送方向:来自外设
;;;97     	DMA_InitStructure.DMA_BufferSize = 1;								             //传送内存大小，1个16位
000036  a901              ADD      r1,sp,#4
000038  2501              MOVS     r5,#1
00003a  e8810031          STM      r1,{r0,r4,r5}
;;;98     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; //外设地址寄存器不变
;;;99     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				   //传送内存地址递增
00003e  2080              MOVS     r0,#0x80
000040  e9cd4004          STRD     r4,r0,[sp,#0x10]
;;;100    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//ADC1转换的数据是16位
000044  0040              LSLS     r0,r0,#1
;;;101    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;//传送的目的地址是16位宽度
000046  9006              STR      r0,[sp,#0x18]
000048  0080              LSLS     r0,r0,#2
;;;102    	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;									 //循环
00004a  9007              STR      r0,[sp,#0x1c]
00004c  2020              MOVS     r0,#0x20
;;;103    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;							 //高优先级
00004e  9008              STR      r0,[sp,#0x20]
000050  0200              LSLS     r0,r0,#8
;;;104    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;										 //没有内存到内存
;;;105    	DMA_Init(DMA1_Channel1, &DMA_InitStructure);	
000052  e9cd0409          STRD     r0,r4,[sp,#0x24]
000056  4669              MOV      r1,sp
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       DMA_Init
;;;106    	//使能DMA通道1
;;;107    	DMA_Cmd(DMA1_Channel1, ENABLE); 
00005e  2101              MOVS     r1,#1
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       DMA_Cmd
;;;108      
;;;109    	
;;;110    	//ADC配置
;;;111    	/* ADC转换时间： 时钟为56MHz时为1μs(时钟为72MHz为1.17μs)   ADC采样范围0-3.3V */
;;;112    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);                   //设置ADC的时钟为72MHZ/6=12M 
000066  03e8              LSLS     r0,r5,#15
000068  f7fffffe          BL       RCC_ADCCLKConfig
;;;113    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//ADC1工作在独立模式
;;;114    	ADC_InitStructure.ADC_ScanConvMode = ENABLE;		    //模数转换工作在扫描模式
00006c  f88d5030          STRB     r5,[sp,#0x30]
000070  940b              STR      r4,[sp,#0x2c]
;;;115    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	//模数转换工作在连续模式
000072  f88d5031          STRB     r5,[sp,#0x31]
;;;116    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//转换由软件触发启动
000076  f44f2060          MOV      r0,#0xe0000
00007a  e9cd040d          STRD     r0,r4,[sp,#0x34]
;;;117    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC数据右对齐
;;;118    	ADC_InitStructure.ADC_NbrOfChannel = 1;             //规定了顺序进行规则转换的ADC通道的数目。
;;;119    	ADC_Init(ADC1, &ADC_InitStructure);
00007e  4c18              LDR      r4,|L1.224|
000080  f88d503c          STRB     r5,[sp,#0x3c]         ;118
000084  3c4c              SUBS     r4,r4,#0x4c
000086  a90b              ADD      r1,sp,#0x2c
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       ADC_Init
;;;120    	
;;;121    	/* ADC1 regular channels configuration [规则模式通道配置]*/ 
;;;122    	//ADC1 规则通道配置
;;;123      ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_55Cycles5);//通道11采样时间 55.5个周期	
00008e  2305              MOVS     r3,#5
000090  2201              MOVS     r2,#1
000092  210b              MOVS     r1,#0xb
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       ADC_RegularChannelConfig
;;;124    	//使能DMA 
;;;125    	ADC_DMACmd(ADC1, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       ADC_DMACmd
;;;126    	//使能ADC1
;;;127    	ADC_Cmd(ADC1, ENABLE);	
0000a2  2101              MOVS     r1,#1
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       ADC_Cmd
;;;128    	// 初始化ADC1校准寄存器
;;;129    	ADC_ResetCalibration(ADC1);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       ADC_ResetCalibration
                  |L1.176|
;;;130    	//检测ADC1校准寄存器初始化是否完成
;;;131    	while(ADC_GetResetCalibrationStatus(ADC1));
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000b6  2800              CMP      r0,#0
0000b8  d1fa              BNE      |L1.176|
;;;132    	//开始校准ADC1
;;;133    	ADC_StartCalibration(ADC1);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       ADC_StartCalibration
                  |L1.192|
;;;134    	//检测是否完成校准
;;;135    	while(ADC_GetCalibrationStatus(ADC1));
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       ADC_GetCalibrationStatus
0000c6  2800              CMP      r0,#0
0000c8  d1fa              BNE      |L1.192|
;;;136    	//ADC1转换启动
;;;137    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	 
0000ca  2101              MOVS     r1,#1
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;138    }
0000d2  b012              ADD      sp,sp,#0x48
0000d4  bd70              POP      {r4-r6,pc}
;;;139    /****************************************************************************
                          ENDP

0000d6  0000              DCW      0x0000
                  |L1.216|
                          DCD      0x40011000
                  |L1.220|
                          DCD      0x40020008
                  |L1.224|
                          DCD      0x4001244c
                  |L1.228|
                          DCD      ||.data||+0x2

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;146    ****************************************************************************/ 
;;;147    void RCC_Configuration(void){
000000  b510              PUSH     {r4,lr}
;;;148    
;;;149      SystemInit(); 		//系统时钟
000002  f7fffffe          BL       SystemInit
;;;150      RCC_ADCCLKConfig(RCC_PCLK2_Div6); 
000006  f44f4000          MOV      r0,#0x8000
00000a  f7fffffe          BL       RCC_ADCCLKConfig
;;;151      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);//复用时钟
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;152      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);	//DMA时钟
000016  2101              MOVS     r1,#1
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;153      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);	//ADC时钟
00001e  2101              MOVS     r1,#1
000020  0248              LSLS     r0,r1,#9
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;154      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC 
000026  2101              MOVS     r1,#1
000028  e8bd4010          POP      {r4,lr}
00002c  207c              MOVS     r0,#0x7c
00002e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;155      						| RCC_APB2Periph_GPIOD| RCC_APB2Periph_GPIOE , ENABLE);//GPIO时钟
;;;156    }
;;;157    
                          ENDP


                          AREA ||i.USART_OUT||, CODE, READONLY, ALIGN=1

                  USART_OUT PROC
;;;264    ****************************************************************************/
;;;265    void USART_OUT(USART_TypeDef* USARTx, uint8_t *Data,...){ 
000000  b40f              PUSH     {r0-r3}
000002  b57f              PUSH     {r0-r6,lr}
000004  4605              MOV      r5,r0
;;;266    
;;;267    	const char *s;
;;;268        int d;
;;;269       
;;;270        char buf[16];
;;;271        va_list ap;
;;;272        va_start(ap, Data);
000006  ac0a              ADD      r4,sp,#0x28
000008  e00f              B        |L3.42|
                  |L3.10|
;;;273    
;;;274    	while(*Data!=0){				                          //判断是否到达字符串结束符
;;;275    		if(*Data==0x5c){									  //'\'
00000a  295c              CMP      r1,#0x5c
00000c  d014              BEQ      |L3.56|
;;;276    			switch (*++Data){
;;;277    				case 'r':							          //回车符
;;;278    					USART_SendData(USARTx, 0x0d);	   
;;;279    
;;;280    					Data++;
;;;281    					break;
;;;282    				case 'n':							          //换行符
;;;283    					USART_SendData(USARTx, 0x0a);	
;;;284    					Data++;
;;;285    					break;
;;;286    				
;;;287    				default:
;;;288    					Data++;
;;;289    				    break;
;;;290    			}
;;;291    			
;;;292    			 
;;;293    		}
;;;294    		else if(*Data=='%'){									  //
00000e  f1020201          ADD      r2,r2,#1
000012  2925              CMP      r1,#0x25
000014  9209              STR      r2,[sp,#0x24]
000016  d01d              BEQ      |L3.84|
;;;295    			switch (*++Data){				
;;;296    				case 's':										  //字符串
;;;297                    	s = va_arg(ap, const char *);
;;;298                    	for ( ; *s; s++) {
;;;299                        	USART_SendData(USARTx,*s);
;;;300    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
;;;301                    	}
;;;302    					Data++;
;;;303                    	break;
;;;304                	case 'd':										  //十进制
;;;305                    	d = va_arg(ap, int);
;;;306                    	itoa(d, buf, 10);
;;;307                    	for (s = buf; *s; s++) {
;;;308                        	USART_SendData(USARTx,*s);
;;;309    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
;;;310                    	}
;;;311    					Data++;
;;;312                    	break;
;;;313    				default:
;;;314    					Data++;
;;;315    				    break;
;;;316    			}		 
;;;317    		}
;;;318    		else USART_SendData(USARTx, *Data++);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       USART_SendData
                  |L3.30|
;;;319    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
00001e  2140              MOVS     r1,#0x40
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       USART_GetFlagStatus
000026  2800              CMP      r0,#0
000028  d0f9              BEQ      |L3.30|
                  |L3.42|
00002a  9a09              LDR      r2,[sp,#0x24]         ;274
00002c  7811              LDRB     r1,[r2,#0]            ;274
00002e  2900              CMP      r1,#0                 ;274
000030  d1eb              BNE      |L3.10|
;;;320    	}
;;;321    }
000032  bc7f              POP      {r0-r6}
000034  f85dfb14          LDR      pc,[sp],#0x14
                  |L3.56|
000038  1c52              ADDS     r2,r2,#1
00003a  9209              STR      r2,[sp,#0x24]         ;276
00003c  7810              LDRB     r0,[r2,#0]            ;276
00003e  286e              CMP      r0,#0x6e              ;276
000040  d003              BEQ      |L3.74|
000042  2872              CMP      r0,#0x72              ;276
000044  d10b              BNE      |L3.94|
000046  210d              MOVS     r1,#0xd               ;278
000048  e000              B        |L3.76|
                  |L3.74|
00004a  210a              MOVS     r1,#0xa               ;283
                  |L3.76|
00004c  4628              MOV      r0,r5                 ;283
00004e  f7fffffe          BL       USART_SendData
000052  e016              B        |L3.130|
                  |L3.84|
000054  7810              LDRB     r0,[r2,#0]            ;295
000056  2864              CMP      r0,#0x64              ;295
000058  d017              BEQ      |L3.138|
00005a  2873              CMP      r0,#0x73              ;295
00005c  d002              BEQ      |L3.100|
                  |L3.94|
00005e  1c52              ADDS     r2,r2,#1              ;295
000060  9209              STR      r2,[sp,#0x24]         ;315
000062  e7dc              B        |L3.30|
                  |L3.100|
000064  cc40              LDM      r4!,{r6}              ;297
000066  e009              B        |L3.124|
                  |L3.104|
000068  4628              MOV      r0,r5                 ;299
00006a  f7fffffe          BL       USART_SendData
                  |L3.110|
00006e  2140              MOVS     r1,#0x40              ;300
000070  4628              MOV      r0,r5                 ;300
000072  f7fffffe          BL       USART_GetFlagStatus
000076  2800              CMP      r0,#0                 ;300
000078  d0f9              BEQ      |L3.110|
00007a  1c76              ADDS     r6,r6,#1              ;300
                  |L3.124|
00007c  7831              LDRB     r1,[r6,#0]            ;298
00007e  2900              CMP      r1,#0                 ;298
000080  d1f2              BNE      |L3.104|
                  |L3.130|
000082  9809              LDR      r0,[sp,#0x24]         ;302
000084  1c40              ADDS     r0,r0,#1              ;302
000086  9009              STR      r0,[sp,#0x24]         ;303
000088  e7c9              B        |L3.30|
                  |L3.138|
00008a  cc01              LDM      r4!,{r0}              ;305
00008c  220a              MOVS     r2,#0xa               ;306
00008e  4669              MOV      r1,sp                 ;306
000090  f7fffffe          BL       itoa
000094  466e              MOV      r6,sp                 ;307
000096  e009              B        |L3.172|
                  |L3.152|
000098  4628              MOV      r0,r5                 ;308
00009a  f7fffffe          BL       USART_SendData
                  |L3.158|
00009e  2140              MOVS     r1,#0x40              ;309
0000a0  4628              MOV      r0,r5                 ;309
0000a2  f7fffffe          BL       USART_GetFlagStatus
0000a6  2800              CMP      r0,#0                 ;309
0000a8  d0f9              BEQ      |L3.158|
0000aa  1c76              ADDS     r6,r6,#1              ;309
                  |L3.172|
0000ac  7831              LDRB     r1,[r6,#0]            ;307
0000ae  2900              CMP      r1,#0                 ;307
0000b0  d1f2              BNE      |L3.152|
0000b2  e7e6              B        |L3.130|
;;;322    /******************* (C) COPYRIGHT 2013 奋斗STM32 *****END OF FILE****/
                          ENDP


                          AREA ||i.Usart1_Init||, CODE, READONLY, ALIGN=2

                  Usart1_Init PROC
;;;165    ****************************************************************************/
;;;166    void Usart1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168      GPIO_InitTypeDef GPIO_InitStructure;
;;;169      USART_InitTypeDef USART_InitStructure;
;;;170      RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 , ENABLE);//使能串口1时钟
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;167
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;171    
;;;172      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;	         		 //USART1 TX  - PA9
00000c  f44f7000          MOV      r0,#0x200
000010  f8ad0010          STRH     r0,[sp,#0x10]
;;;173      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0012          STRB     r0,[sp,#0x12]
;;;174      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    		 //复用推挽输出
00001a  2018              MOVS     r0,#0x18
;;;175      GPIO_Init(GPIOA, &GPIO_InitStructure);		    		 		
00001c  4c15              LDR      r4,|L4.116|
00001e  f88d0013          STRB     r0,[sp,#0x13]         ;174
000022  a904              ADD      r1,sp,#0x10
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_Init
;;;176    
;;;177      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;	         	 //USART1 RX  - PA10
00002a  1520              ASRS     r0,r4,#20
00002c  f8ad0010          STRH     r0,[sp,#0x10]
;;;178      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //复用开漏输入
000030  2004              MOVS     r0,#4
000032  f88d0013          STRB     r0,[sp,#0x13]
;;;179      GPIO_Init(GPIOA, &GPIO_InitStructure);		         	
000036  a904              ADD      r1,sp,#0x10
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       GPIO_Init
;;;180    
;;;181      USART_InitStructure.USART_BaudRate = 115200;								//速率115200bps
00003e  f44f30e1          MOV      r0,#0x1c200
;;;182      USART_InitStructure.USART_WordLength = USART_WordLength_8b;	//数据位8位
000042  9000              STR      r0,[sp,#0]
000044  2000              MOVS     r0,#0
000046  f8ad0004          STRH     r0,[sp,#4]
;;;183      USART_InitStructure.USART_StopBits = USART_StopBits_1;			//停止位1位
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;184      USART_InitStructure.USART_Parity = USART_Parity_No;				  //无校验位
00004e  f8ad0008          STRH     r0,[sp,#8]
;;;185      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件流控
000052  f8ad000c          STRH     r0,[sp,#0xc]
;;;186      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000056  200c              MOVS     r0,#0xc
;;;187    
;;;188      /* Configure USART1 */
;;;189      USART_Init(USART1, &USART_InitStructure);							//配置串口参数函数   
000058  4c07              LDR      r4,|L4.120|
00005a  f8ad000a          STRH     r0,[sp,#0xa]          ;186
00005e  4669              MOV      r1,sp
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       USART_Init
;;;190       /* Enable the USART1 */
;;;191      USART_Cmd(USART1, ENABLE);	
000066  2101              MOVS     r1,#1
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       USART_Cmd
;;;192      
;;;193    }
00006e  b006              ADD      sp,sp,#0x18
000070  bd10              POP      {r4,pc}
;;;194    /******************************************************
                          ENDP

000072  0000              DCW      0x0000
                  |L4.116|
                          DCD      0x40010800
                  |L4.120|
                          DCD      0x40013800

                          AREA ||i.itoa||, CODE, READONLY, ALIGN=2

                  itoa PROC
;;;203    **********************************************************/
;;;204    char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;205    {
;;;206        int     i, d;
;;;207        int     flag = 0;
000002  2600              MOVS     r6,#0
;;;208        char    *ptr = string;
000004  460b              MOV      r3,r1
000006  4635              MOV      r5,r6
;;;209    
;;;210        /* This implementation only works for decimal numbers. */
;;;211        if (radix != 10)
000008  2a0a              CMP      r2,#0xa
00000a  d002              BEQ      |L5.18|
;;;212        {
;;;213            *ptr = 0;
00000c  700d              STRB     r5,[r1,#0]
;;;214            return string;
00000e  4618              MOV      r0,r3
;;;215        }
;;;216    
;;;217        if (!value)
;;;218        {
;;;219            *ptr++ = 0x30;
;;;220            *ptr = 0;
;;;221            return string;
;;;222        }
;;;223    
;;;224        /* if this is a negative value insert the minus sign. */
;;;225        if (value < 0)
;;;226        {
;;;227            *ptr++ = '-';
;;;228    
;;;229            /* Make the value positive. */
;;;230            value *= -1;
;;;231        }
;;;232    
;;;233        for (i = 10000; i > 0; i /= 10)
;;;234        {
;;;235            d = value / i;
;;;236    
;;;237            if (d || flag)
;;;238            {
;;;239                *ptr++ = (char)(d + 0x30);
;;;240                value -= (d * i);
;;;241                flag = 1;
;;;242            }
;;;243        }
;;;244    
;;;245        /* Null terminate the string. */
;;;246        *ptr = 0;
;;;247    
;;;248        return string;
;;;249    
;;;250    } /* NCL_Itoa */
000010  bdf0              POP      {r4-r7,pc}
                  |L5.18|
000012  2800              CMP      r0,#0                 ;217
000014  d01f              BEQ      |L5.86|
000016  da06              BGE      |L5.38|
000018  f04f022d          MOV      r2,#0x2d              ;227
00001c  701a              STRB     r2,[r3,#0]            ;227
00001e  f1010301          ADD      r3,r1,#1              ;227
000022  f1c00000          RSB      r0,r0,#0              ;230
                  |L5.38|
000026  f2427410          MOV      r4,#0x2710            ;233
00002a  f04f070a          MOV      r7,#0xa               ;205
00002e  bf00              NOP                            ;235
                  |L5.48|
000030  fb90f2f4          SDIV     r2,r0,r4              ;235
000034  ea520c06          ORRS     r12,r2,r6             ;237
000038  d006              BEQ      |L5.72|
00003a  f1020630          ADD      r6,r2,#0x30           ;239
00003e  f8036b01          STRB     r6,[r3],#1            ;239
000042  fb020014          MLS      r0,r2,r4,r0           ;240
000046  2601              MOVS     r6,#1                 ;241
                  |L5.72|
000048  fb94f4f7          SDIV     r4,r4,r7              ;233
00004c  2c00              CMP      r4,#0                 ;233
00004e  dcef              BGT      |L5.48|
                  |L5.80|
000050  701d              STRB     r5,[r3,#0]            ;246
000052  4608              MOV      r0,r1                 ;248
000054  bdf0              POP      {r4-r7,pc}
                  |L5.86|
000056  2030              MOVS     r0,#0x30              ;219
000058  7018              STRB     r0,[r3,#0]            ;219
00005a  1c4b              ADDS     r3,r1,#1              ;219
00005c  e7f8              B        |L5.80|
;;;251    /****************************************************************************
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;50     ****************************************************************************/ 
;;;51     int main(void)
000000  f7fffffe          BL       RCC_Configuration
;;;52     {	
;;;53       RCC_Configuration();	         //配置时钟
;;;54       Usart1_Init();		             //串口1初始化  
000004  f7fffffe          BL       Usart1_Init
;;;55       ADC_Configuration();				   //ADC初始化
000008  f7fffffe          BL       ADC_Configuration
;;;56       USART_OUT(USART1,"\r\n USART1 print AD_value -------------------------- \r\n"); 
00000c  4c1e              LDR      r4,|L6.136|
00000e  a110              ADR      r1,|L6.80|
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       USART_OUT
000016  46a0              MOV      r8,r4
;;;57       while(1)
;;;58       {
;;;59       	 if (ticks++ >= 900000) {        //间隔时间显示转换结果
000018  4e1c              LDR      r6,|L6.140|
;;;60          	ticks   = 0;
;;;61          	Clock1s = 1;
00001a  2701              MOVS     r7,#1
00001c  4c1c              LDR      r4,|L6.144|
00001e  2500              MOVS     r5,#0
                  |L6.32|
000020  6860              LDR      r0,[r4,#4]            ;59  ; ticks
000022  1c41              ADDS     r1,r0,#1              ;59
000024  6061              STR      r1,[r4,#4]            ;59  ; ticks
000026  42b0              CMP      r0,r6                 ;59
000028  d302              BCC      |L6.48|
00002a  6065              STR      r5,[r4,#4]  ; ticks
00002c  7027              STRB     r7,[r4,#0]
00002e  e002              B        |L6.54|
                  |L6.48|
;;;62        	 }
;;;63     	 if (Clock1s) {
000030  7820              LDRB     r0,[r4,#0]  ; Clock1s
000032  2800              CMP      r0,#0
000034  d0f4              BEQ      |L6.32|
                  |L6.54|
;;;64            Clock1s = 0;      
000036  7025              STRB     r5,[r4,#0]
;;;65     	   USART_OUT(USART1,"The current AD value = %d , as voltage = %d mV\r\n", ADC_ConvertedValue ,(ADC_ConvertedValue * 825)>>10);
000038  8860              LDRH     r0,[r4,#2]  ; ADC_ConvertedValue
00003a  f2403139          MOV      r1,#0x339
00003e  4348              MULS     r0,r1,r0
000040  8862              LDRH     r2,[r4,#2]  ; ADC_ConvertedValue
000042  0a83              LSRS     r3,r0,#10
000044  a113              ADR      r1,|L6.148|
000046  4640              MOV      r0,r8
000048  f7fffffe          BL       USART_OUT
00004c  e7e8              B        |L6.32|
;;;66          }  
;;;67       }
;;;68     }
;;;69     /****************************************************************************
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
000050  0d0a2055          DCB      "\r\n USART1 print AD_value -------------------------- \r"
000054  53415254
000058  31207072
00005c  696e7420
000060  41445f76
000064  616c7565
000068  202d2d2d
00006c  2d2d2d2d
000070  2d2d2d2d
000074  2d2d2d2d
000078  2d2d2d2d
00007c  2d2d2d2d
000080  2d2d2d20
000084  0d      
000085  0a00              DCB      "\n",0
000087  00                DCB      0
                  |L6.136|
                          DCD      0x40013800
                  |L6.140|
                          DCD      0x000dbba0
                  |L6.144|
                          DCD      ||.data||
                  |L6.148|
000094  54686520          DCB      "The current AD value = %d , as voltage = %d mV\r\n",0
000098  63757272
00009c  656e7420
0000a0  41442076
0000a4  616c7565
0000a8  203d2025
0000ac  64202c20
0000b0  61732076
0000b4  6f6c7461
0000b8  6765203d
0000bc  20256420
0000c0  6d560d0a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  Clock1s
000000  0000              DCB      0x00,0x00
                  ADC_ConvertedValue
000002  0000              DCB      0x00,0x00
                  ticks
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
