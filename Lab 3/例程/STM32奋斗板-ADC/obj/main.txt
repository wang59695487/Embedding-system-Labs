; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\main.o --depend=.\obj\main.d --device=DARMSTM --apcs=interwork -O3 -I.\FWlib\inc -I.\user -I.\CM3 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\main.crf user\main.c]
                          THUMB

                          AREA ||i.ADC_Configuration||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;77     ****************************************************************************/ 
;;;78     void ADC_Configuration(void)
000000  b570              PUSH     {r4-r6,lr}
;;;79     {
000002  b092              SUB      sp,sp,#0x48
;;;80     	ADC_InitTypeDef ADC_InitStructure;
;;;81     	GPIO_InitTypeDef GPIO_InitStructure;
;;;82     	DMA_InitTypeDef DMA_InitStructure;
;;;83     
;;;84         //设置AD模拟输入端口为输入 1路AD 规则通道
;;;85       	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000004  2002              MOVS     r0,#2
000006  f8ad0030          STRH     r0,[sp,#0x30]
;;;86       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00000a  2400              MOVS     r4,#0
00000c  f88d4033          STRB     r4,[sp,#0x33]
;;;87       	GPIO_Init(GPIOC, &GPIO_InitStructure);
000010  a90c              ADD      r1,sp,#0x30
000012  4830              LDR      r0,|L1.212|
000014  f7fffffe          BL       GPIO_Init
;;;88     	/* Enable DMA clock */
;;;89         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;90     
;;;91        /* Enable ADC1 and GPIOC clock */
;;;92         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
000020  2101              MOVS     r1,#1
000022  0248              LSLS     r0,r1,#9
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;93     
;;;94       	/* DMA channel1 configuration ----------------------------------------------*/
;;;95     	//使能DMA
;;;96     	DMA_DeInit(DMA1_Channel1);
000028  4e2b              LDR      r6,|L1.216|
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       DMA_DeInit
;;;97     	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;			            //DMA通道1的地址 
000030  482a              LDR      r0,|L1.220|
;;;98     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;	            //DMA传送地址
000032  9001              STR      r0,[sp,#4]
000034  482a              LDR      r0,|L1.224|
;;;99     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;					            //传送方向
;;;100    	DMA_InitStructure.DMA_BufferSize = 1;								            //传送内存大小，1个16位
000036  2501              MOVS     r5,#1
;;;101    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	 
000038  a902              ADD      r1,sp,#8
00003a  c131              STM      r1!,{r0,r4,r5}
;;;102    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				            //传送内存地址递增
00003c  2080              MOVS     r0,#0x80
;;;103    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;		//ADC1转换的数据是16位
00003e  e9cd4005          STRD     r4,r0,[sp,#0x14]
000042  0040              LSLS     r0,r0,#1
;;;104    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;				//传送的目的地址是16位宽度
000044  9007              STR      r0,[sp,#0x1c]
000046  0080              LSLS     r0,r0,#2
;;;105    	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;									//循环
000048  9008              STR      r0,[sp,#0x20]
00004a  2020              MOVS     r0,#0x20
;;;106    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00004c  9009              STR      r0,[sp,#0x24]
00004e  0200              LSLS     r0,r0,#8
;;;107    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;108    	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000050  e9cd040a          STRD     r0,r4,[sp,#0x28]
000054  a901              ADD      r1,sp,#4
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       DMA_Init
;;;109        
;;;110    	/* 允许DMA1通道1传输结束中断 */
;;;111    	//DMA_ITConfig(DMA1_Channel1,DMA_IT_TC, ENABLE);
;;;112    
;;;113    
;;;114    	//使能DMA通道1
;;;115    	DMA_Cmd(DMA1_Channel1, ENABLE); 
00005c  2101              MOVS     r1,#1
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       DMA_Cmd
;;;116      
;;;117      
;;;118    	//ADC配置
;;;119    	/* ADC转换时间： ─ STM32F103xx增强型产品：时钟为56MHz时为1μs(时钟为72MHz为1.17μs)
;;;120    	ADC采样范围0-3.3V    */
;;;121    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);                   //设置ADC的时钟为72MHZ/6=12M 
000064  03e8              LSLS     r0,r5,#15
000066  f7fffffe          BL       RCC_ADCCLKConfig
;;;122    
;;;123    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//ADC1工作在独立模式
;;;124    	ADC_InitStructure.ADC_ScanConvMode = ENABLE;		//模数转换工作在扫描模式（多通道）还是单次（单通道）模式
00006a  f88d5038          STRB     r5,[sp,#0x38]
00006e  940d              STR      r4,[sp,#0x34]
;;;125    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	//模数转换工作在连续模式，还是单次模式
000070  f88d5039          STRB     r5,[sp,#0x39]
;;;126    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//转换由软件而不是外部触发启动
000074  f44f2060          MOV      r0,#0xe0000
;;;127    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC数据右对齐
;;;128    	ADC_InitStructure.ADC_NbrOfChannel = 1;               //规定了顺序进行规则转换的ADC通道的数目。这个数目的取值范围是1到16
000078  e9cd040f          STRD     r0,r4,[sp,#0x3c]
;;;129    	ADC_Init(ADC1, &ADC_InitStructure);
00007c  4c17              LDR      r4,|L1.220|
00007e  f88d5044          STRB     r5,[sp,#0x44]         ;128
000082  3c4c              SUBS     r4,r4,#0x4c
000084  a90d              ADD      r1,sp,#0x34
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       ADC_Init
;;;130    	
;;;131    	/* ADC1 regular channels configuration [规则模式通道配置]*/ 
;;;132    
;;;133    	//ADC1 规则通道配置
;;;134      	ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_55Cycles5);	  //通道11采样时间 55.5周期
00008c  2305              MOVS     r3,#5
00008e  2201              MOVS     r2,#1
000090  210b              MOVS     r1,#0xb
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       ADC_RegularChannelConfig
;;;135      	
;;;136    
;;;137    	//使能ADC1 DMA 
;;;138    	ADC_DMACmd(ADC1, ENABLE);
000098  2101              MOVS     r1,#1
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       ADC_DMACmd
;;;139    	//使能ADC1
;;;140    	ADC_Cmd(ADC1, ENABLE);	
0000a0  2101              MOVS     r1,#1
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       ADC_Cmd
;;;141    	
;;;142    	// 初始化ADC1校准寄存器
;;;143    	ADC_ResetCalibration(ADC1);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       ADC_ResetCalibration
                  |L1.174|
;;;144    	//检测ADC1校准寄存器初始化是否完成
;;;145    	while(ADC_GetResetCalibrationStatus(ADC1));
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000b4  2800              CMP      r0,#0
0000b6  d1fa              BNE      |L1.174|
;;;146    	
;;;147    	//开始校准ADC1
;;;148    	ADC_StartCalibration(ADC1);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       ADC_StartCalibration
                  |L1.190|
;;;149    	//检测是否完成校准
;;;150    	while(ADC_GetCalibrationStatus(ADC1));
0000be  4620              MOV      r0,r4
0000c0  f7fffffe          BL       ADC_GetCalibrationStatus
0000c4  2800              CMP      r0,#0
0000c6  d1fa              BNE      |L1.190|
;;;151    	
;;;152    	//ADC1转换启动
;;;153    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	 
0000c8  2101              MOVS     r1,#1
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;154    }
0000d0  b012              ADD      sp,sp,#0x48
0000d2  bd70              POP      {r4-r6,pc}
;;;155    /****************************************************************************
                          ENDP

                  |L1.212|
                          DCD      0x40011000
                  |L1.216|
                          DCD      0x40020008
                  |L1.220|
                          DCD      0x4001244c
                  |L1.224|
                          DCD      ||.data||+0x2

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;162    ****************************************************************************/ 
;;;163    void RCC_Configuration(void){
000000  b510              PUSH     {r4,lr}
;;;164    
;;;165      SystemInit(); 
000002  f7fffffe          BL       SystemInit
;;;166      RCC_ADCCLKConfig(RCC_PCLK2_Div6); 
000006  f44f4000          MOV      r0,#0x8000
00000a  f7fffffe          BL       RCC_ADCCLKConfig
;;;167      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;168      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000016  2101              MOVS     r1,#1
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;169      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
00001e  2101              MOVS     r1,#1
000020  0248              LSLS     r0,r1,#9
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;170      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC 
000026  2101              MOVS     r1,#1
000028  e8bd4010          POP      {r4,lr}
00002c  207c              MOVS     r0,#0x7c
00002e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;171      						| RCC_APB2Periph_GPIOD| RCC_APB2Periph_GPIOE , ENABLE);
;;;172    }
;;;173    
                          ENDP


                          AREA ||i.USART_OUT||, CODE, READONLY, ALIGN=1

                  USART_OUT PROC
;;;287    ****************************************************************************/
;;;288    void USART_OUT(USART_TypeDef* USARTx, uint8_t *Data,...){ 
000000  b40f              PUSH     {r0-r3}
000002  b57f              PUSH     {r0-r6,lr}
000004  4606              MOV      r6,r0
;;;289    
;;;290    	const char *s;
;;;291        int d;
;;;292       
;;;293        char buf[16];
;;;294        va_list ap;
;;;295        va_start(ap, Data);
000006  ad0a              ADD      r5,sp,#0x28
;;;296    
;;;297    	while(*Data!=0){				                          //判断是否到达字符串结束符
000008  e04a              B        |L3.160|
                  |L3.10|
;;;298    		if(*Data==0x5c){									  //'\'
00000a  295c              CMP      r1,#0x5c
00000c  d10d              BNE      |L3.42|
;;;299    			switch (*++Data){
00000e  1c40              ADDS     r0,r0,#1
000010  9009              STR      r0,[sp,#0x24]
000012  7801              LDRB     r1,[r0,#0]
000014  296e              CMP      r1,#0x6e
000016  d003              BEQ      |L3.32|
000018  2972              CMP      r1,#0x72
00001a  d120              BNE      |L3.94|
;;;300    				case 'r':							          //回车符
;;;301    					USART_SendData(USARTx, 0x0d);	   
00001c  210d              MOVS     r1,#0xd
;;;302    
;;;303    					Data++;
;;;304    					break;
00001e  e000              B        |L3.34|
                  |L3.32|
;;;305    				case 'n':							          //换行符
;;;306    					USART_SendData(USARTx, 0x0a);	
000020  210a              MOVS     r1,#0xa
                  |L3.34|
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       USART_SendData
000028  e018              B        |L3.92|
                  |L3.42|
;;;307    					Data++;
;;;308    					break;
;;;309    				
;;;310    				default:
;;;311    					Data++;
;;;312    				    break;
;;;313    			}
;;;314    			
;;;315    			 
;;;316    		}
;;;317    		else if(*Data=='%'){									  //
;;;318    			switch (*++Data){				
00002a  f1000001          ADD      r0,r0,#1
00002e  2925              CMP      r1,#0x25              ;317
000030  9009              STR      r0,[sp,#0x24]         ;317
000032  d12c              BNE      |L3.142|
000034  7801              LDRB     r1,[r0,#0]
000036  2964              CMP      r1,#0x64
000038  d014              BEQ      |L3.100|
00003a  2973              CMP      r1,#0x73
00003c  d10f              BNE      |L3.94|
;;;319    				case 's':										  //字符串
;;;320                    	s = va_arg(ap, const char *);
00003e  cd10              LDM      r5!,{r4}
;;;321                    	for ( ; *s; s++) {
000040  e009              B        |L3.86|
                  |L3.66|
;;;322                        	USART_SendData(USARTx,*s);
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       USART_SendData
                  |L3.72|
;;;323    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
000048  2140              MOVS     r1,#0x40
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       USART_GetFlagStatus
000050  2800              CMP      r0,#0
000052  d0f9              BEQ      |L3.72|
000054  1c64              ADDS     r4,r4,#1              ;321
                  |L3.86|
000056  7821              LDRB     r1,[r4,#0]            ;321
000058  2900              CMP      r1,#0                 ;321
00005a  d1f2              BNE      |L3.66|
                  |L3.92|
;;;324                    	}
;;;325    					Data++;
00005c  9809              LDR      r0,[sp,#0x24]
                  |L3.94|
;;;326                    	break;
;;;327                	case 'd':										  //十进制
;;;328                    	d = va_arg(ap, int);
;;;329                    	itoa(d, buf, 10);
;;;330                    	for (s = buf; *s; s++) {
;;;331                        	USART_SendData(USARTx,*s);
;;;332    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
;;;333                    	}
;;;334    					Data++;
;;;335                    	break;
;;;336    				default:
;;;337    					Data++;
00005e  1c40              ADDS     r0,r0,#1
;;;338    				    break;
000060  9009              STR      r0,[sp,#0x24]
000062  e017              B        |L3.148|
                  |L3.100|
000064  cd01              LDM      r5!,{r0}              ;328
000066  220a              MOVS     r2,#0xa               ;329
000068  4669              MOV      r1,sp                 ;329
00006a  f7fffffe          BL       itoa
00006e  466c              MOV      r4,sp                 ;330
000070  e009              B        |L3.134|
                  |L3.114|
000072  4630              MOV      r0,r6                 ;331
000074  f7fffffe          BL       USART_SendData
                  |L3.120|
000078  2140              MOVS     r1,#0x40              ;332
00007a  4630              MOV      r0,r6                 ;332
00007c  f7fffffe          BL       USART_GetFlagStatus
000080  2800              CMP      r0,#0                 ;332
000082  d0f9              BEQ      |L3.120|
000084  1c64              ADDS     r4,r4,#1              ;330
                  |L3.134|
000086  7821              LDRB     r1,[r4,#0]            ;330
000088  2900              CMP      r1,#0                 ;330
00008a  d1f2              BNE      |L3.114|
00008c  e7e6              B        |L3.92|
                  |L3.142|
;;;339    			}		 
;;;340    		}
;;;341    		else USART_SendData(USARTx, *Data++);
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       USART_SendData
                  |L3.148|
;;;342    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
000094  2140              MOVS     r1,#0x40
000096  4630              MOV      r0,r6
000098  f7fffffe          BL       USART_GetFlagStatus
00009c  2800              CMP      r0,#0
00009e  d0f9              BEQ      |L3.148|
                  |L3.160|
0000a0  9809              LDR      r0,[sp,#0x24]         ;297
0000a2  7801              LDRB     r1,[r0,#0]            ;297
0000a4  2900              CMP      r1,#0                 ;297
0000a6  d1b0              BNE      |L3.10|
;;;343    	}
;;;344    }
0000a8  bc7f              POP      {r0-r6}
0000aa  f85dfb14          LDR      pc,[sp],#0x14
;;;345    /******************* (C) COPYRIGHT 2013 奋斗STM32 *****END OF FILE****/
                          ENDP


                          AREA ||i.Usart1_Init||, CODE, READONLY, ALIGN=2

                  Usart1_Init PROC
;;;181    ****************************************************************************/
;;;182    void Usart1_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;183    {
;;;184      GPIO_InitTypeDef GPIO_InitStructure;
;;;185      USART_InitTypeDef USART_InitStructure;
;;;186     
;;;187      RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 , ENABLE);	 //使能串口1时钟
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;183
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;188    
;;;189      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; 			      //LCD背光控制
00000c  f44f5500          MOV      r5,#0x2000
000010  f8ad5014          STRH     r5,[sp,#0x14]
;;;190      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2403              MOVS     r4,#3
000016  f88d4016          STRB     r4,[sp,#0x16]
;;;191      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00001a  2010              MOVS     r0,#0x10
;;;192      GPIO_Init(GPIOD, &GPIO_InitStructure);
00001c  4e1d              LDR      r6,|L4.148|
00001e  f88d0017          STRB     r0,[sp,#0x17]         ;191
000022  a905              ADD      r1,sp,#0x14
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       GPIO_Init
;;;193      GPIO_ResetBits(GPIOD, GPIO_Pin_13);			              //LCD背光关闭	
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       GPIO_ResetBits
;;;194    
;;;195      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;	         		 //USART1 TX
000032  1128              ASRS     r0,r5,#4
000034  f8ad0014          STRH     r0,[sp,#0x14]
;;;196      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000038  f88d4016          STRB     r4,[sp,#0x16]
;;;197      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    		 //复用推挽输出
00003c  2018              MOVS     r0,#0x18
;;;198      GPIO_Init(GPIOA, &GPIO_InitStructure);		    		 //A端口 
00003e  4c16              LDR      r4,|L4.152|
000040  f88d0017          STRB     r0,[sp,#0x17]         ;197
000044  a905              ADD      r1,sp,#0x14
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       GPIO_Init
;;;199    
;;;200      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;	         	 //USART1 RX
00004c  1520              ASRS     r0,r4,#20
00004e  f8ad0014          STRH     r0,[sp,#0x14]
;;;201      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   	 //复用开漏输入
000052  2004              MOVS     r0,#4
000054  f88d0017          STRB     r0,[sp,#0x17]
;;;202      GPIO_Init(GPIOA, &GPIO_InitStructure);		         	 //A端口 
000058  a905              ADD      r1,sp,#0x14
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       GPIO_Init
;;;203    
;;;204      USART_InitStructure.USART_BaudRate = 115200;						//速率115200bps
000060  f44f30e1          MOV      r0,#0x1c200
;;;205      USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//数据位8位
000064  9001              STR      r0,[sp,#4]
000066  2000              MOVS     r0,#0
000068  f8ad0008          STRH     r0,[sp,#8]
;;;206      USART_InitStructure.USART_StopBits = USART_StopBits_1;			//停止位1位
00006c  f8ad000a          STRH     r0,[sp,#0xa]
;;;207      USART_InitStructure.USART_Parity = USART_Parity_No;				//无校验位
000070  f8ad000c          STRH     r0,[sp,#0xc]
;;;208      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;   //无硬件流控
000074  f8ad0010          STRH     r0,[sp,#0x10]
;;;209      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;					//收发模式
000078  200c              MOVS     r0,#0xc
;;;210    
;;;211      /* Configure USART1 */
;;;212      USART_Init(USART1, &USART_InitStructure);							//配置串口参数函数   
00007a  4c08              LDR      r4,|L4.156|
00007c  f8ad000e          STRH     r0,[sp,#0xe]          ;209
000080  a901              ADD      r1,sp,#4
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       USART_Init
;;;213       /* Enable the USART1 */
;;;214      USART_Cmd(USART1, ENABLE);	
000088  2101              MOVS     r1,#1
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       USART_Cmd
;;;215      
;;;216    }
000090  b006              ADD      sp,sp,#0x18
000092  bd70              POP      {r4-r6,pc}
;;;217    /******************************************************
                          ENDP

                  |L4.148|
                          DCD      0x40011400
                  |L4.152|
                          DCD      0x40010800
                  |L4.156|
                          DCD      0x40013800

                          AREA ||i.itoa||, CODE, READONLY, ALIGN=2

                  itoa PROC
;;;226    **********************************************************/
;;;227    char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;228    {
;;;229        int     i, d;
;;;230        int     flag = 0;
000002  2500              MOVS     r5,#0
;;;231        char    *ptr = string;
000004  460b              MOV      r3,r1
000006  462e              MOV      r6,r5                 ;230
;;;232    
;;;233        /* This implementation only works for decimal numbers. */
;;;234        if (radix != 10)
000008  2a0a              CMP      r2,#0xa
00000a  d001              BEQ      |L5.16|
                  |L5.12|
;;;235        {
;;;236            *ptr = 0;
00000c  701e              STRB     r6,[r3,#0]
;;;237            return string;
00000e  e005              B        |L5.28|
                  |L5.16|
;;;238        }
;;;239    
;;;240        if (!value)
000010  2800              CMP      r0,#0
000012  d105              BNE      |L5.32|
;;;241        {
;;;242            *ptr++ = 0x30;
000014  f04f0030          MOV      r0,#0x30
000018  7018              STRB     r0,[r3,#0]
;;;243            *ptr = 0;
00001a  705e              STRB     r6,[r3,#1]
                  |L5.28|
;;;244            return string;
;;;245        }
;;;246    
;;;247        /* if this is a negative value insert the minus sign. */
;;;248        if (value < 0)
;;;249        {
;;;250            *ptr++ = '-';
;;;251    
;;;252            /* Make the value positive. */
;;;253            value *= -1;
;;;254        }
;;;255    
;;;256        for (i = 10000; i > 0; i /= 10)
;;;257        {
;;;258            d = value / i;
;;;259    
;;;260            if (d || flag)
;;;261            {
;;;262                *ptr++ = (char)(d + 0x30);
;;;263                value -= (d * i);
;;;264                flag = 1;
;;;265            }
;;;266        }
;;;267    
;;;268        /* Null terminate the string. */
;;;269        *ptr = 0;
;;;270    
;;;271        return string;
00001c  4608              MOV      r0,r1
;;;272    
;;;273    } /* NCL_Itoa */
00001e  bdf0              POP      {r4-r7,pc}
                  |L5.32|
000020  da05              BGE      |L5.46|
000022  f04f022d          MOV      r2,#0x2d              ;250
000026  f8032b01          STRB     r2,[r3],#1            ;250
00002a  f1c00000          RSB      r0,r0,#0              ;253
                  |L5.46|
00002e  f2427210          MOV      r2,#0x2710            ;256
000032  f04f0c0a          MOV      r12,#0xa              ;228
000036  bf00              NOP                            ;258
                  |L5.56|
000038  fb90f4f2          SDIV     r4,r0,r2              ;258
00003c  ea540705          ORRS     r7,r4,r5              ;260
000040  d006              BEQ      |L5.80|
000042  f1040530          ADD      r5,r4,#0x30           ;262
000046  f8035b01          STRB     r5,[r3],#1            ;262
00004a  fb040012          MLS      r0,r4,r2,r0           ;263
00004e  2501              MOVS     r5,#1                 ;264
                  |L5.80|
000050  fb92f2fc          SDIV     r2,r2,r12             ;256
000054  2a00              CMP      r2,#0                 ;256
000056  dcef              BGT      |L5.56|
000058  e7d8              B        |L5.12|
;;;274    /****************************************************************************
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;51     ****************************************************************************/ 
;;;52     int main(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;53     {	
;;;54       RCC_Configuration();	             //设置内部时钟及外设时钟使能
000004  f7fffffe          BL       RCC_Configuration
;;;55       Usart1_Init();		             //串口1初始化  
000008  f7fffffe          BL       Usart1_Init
;;;56       ADC_Configuration();				 //ADC初始化
00000c  f7fffffe          BL       ADC_Configuration
;;;57       USART_OUT(USART1,"\r\n USART1 print AD_value -------------------------- \r\n"); 
000010  4c1b              LDR      r4,|L6.128|
000012  a10d              ADR      r1,|L6.72|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       USART_OUT
;;;58       while(1)
;;;59       {
;;;60       	 if (ticks++ >= 900000) {        //间隔时间显示转换结果
00001a  4d1a              LDR      r5,|L6.132|
;;;61          	ticks   = 0;
;;;62          	Clock1s = 1;
00001c  2601              MOVS     r6,#1
00001e  46a0              MOV      r8,r4                 ;57
000020  4f19              LDR      r7,|L6.136|
000022  2400              MOVS     r4,#0                 ;61
                  |L6.36|
000024  6878              LDR      r0,[r7,#4]            ;60  ; ticks
000026  1c41              ADDS     r1,r0,#1              ;60
000028  6079              STR      r1,[r7,#4]            ;60  ; ticks
00002a  42a8              CMP      r0,r5                 ;60
00002c  d302              BCC      |L6.52|
00002e  607c              STR      r4,[r7,#4]  ; ticks
000030  703e              STRB     r6,[r7,#0]
000032  e002              B        |L6.58|
                  |L6.52|
;;;63        	 }
;;;64     	 if (Clock1s) {
000034  7838              LDRB     r0,[r7,#0]  ; Clock1s
000036  2800              CMP      r0,#0
000038  d0f4              BEQ      |L6.36|
                  |L6.58|
;;;65            Clock1s = 0;      
00003a  703c              STRB     r4,[r7,#0]
;;;66     	   USART_OUT(USART1,"The current AD value = %d \r\n", ADC_ConvertedValue);
00003c  887a              LDRH     r2,[r7,#2]  ; ADC_ConvertedValue
00003e  a113              ADR      r1,|L6.140|
000040  4640              MOV      r0,r8
000042  f7fffffe          BL       USART_OUT
000046  e7ed              B        |L6.36|
;;;67          }  
;;;68       }
;;;69     }
;;;70     /****************************************************************************
                          ENDP

                  |L6.72|
000048  0d0a20555341525431207072696e742041445f76616c7565202d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d200d        DCB      "\r\n USART1 print AD_value -------------------------- \r"
00007d  0a00              DCB      "\n",0
00007f  00                DCB      0
                  |L6.128|
                          DCD      0x40013800
                  |L6.132|
                          DCD      0x000dbba0
                  |L6.136|
                          DCD      ||.data||
                  |L6.140|
00008c  5468652063757272656e742041442076616c7565203d202564200d0a00        DCB      "The current AD value = %d \r\n",0
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  Clock1s
000000  0000              DCB      0x00,0x00
                  ADC_ConvertedValue
000002  0000              DCB      0x00,0x00
                  ticks
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
